import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

// Load .env like main.js
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const envPath = path.join(__dirname, '.env');
if (fs.existsSync(envPath)) {
  const envContent = fs.readFileSync(envPath, 'utf-8');
  envContent.split('\n').forEach(line => {
    const [k, v] = line.split('=').map(s => s && s.trim());
    if (k && !k.startsWith('#') && v !== undefined) process.env[k] = v;
  });
}

const FOXESS_API_KEY = process.env.FOXESS_API_KEY;
const DEVICE_SN = process.env.DEVICE_SN; // comma separated allowed
const FOXESS_DOMAIN = process.env.FOXESS_DOMAIN || 'https://www.foxesscloud.com';
const POLL_INTERVAL_MS = parseInt(process.env.POLL_INTERVAL_MS || '60000', 10);
const PORT = parseInt(process.env.EXPORTER_PORT || '9200', 10);

if (!FOXESS_API_KEY || !DEVICE_SN) {
  console.error('Please set FOXESS_API_KEY and DEVICE_SN in .env');
  process.exit(1);
}

function md5c(text = "") {
  return crypto.createHash('md5').update(text, 'utf8').digest('hex').toLowerCase();
}

function generateSignature(apiKey, apiPath) {
  const timestamp = new Date().getTime();
  // Use literal \r\n in the signed string (escaped in JS template)
  const signatureRaw = `${apiPath}\\r\\n${apiKey}\\r\\n${timestamp}`;
  const signature = md5c(signatureRaw);
  return {
    token: apiKey,
    lang: 'en',
    timestamp: String(timestamp),
    signature: signature,
    'Content-Type': 'application/json'
  };
}

function sanitizeMetricName(variable) {
  // prefix and replace invalid chars
  return ('foxess_' + variable).replace(/[^a-zA-Z0-9_:]/g, '_');
}

let lastMetrics = '# no metrics yet\n';
let lastFetch = 0;

async function fetchAndBuildMetrics() {
  try {
    const apiPath = '/op/v1/device/real/query';
    const headers = generateSignature(FOXESS_API_KEY, apiPath);
    const sns = DEVICE_SN.split(',').map(s => s.trim()).filter(Boolean);

    const res = await axios.post(`${FOXESS_DOMAIN}${apiPath}`, { sns }, { headers, timeout: 20000 });
    const data = res.data;
    const lines = [];
    lines.push('# Generated by foxess exporter');
    lines.push(`# fetched ${new Date().toISOString()}`);

    // Parse device results and extract metrics robustly
    if (data && data.errno === 0 && Array.isArray(data.result)) {
      for (const device of data.result) {
        const deviceSN = device.deviceSN || device.emsSN || (device.sns && device.sns[0]) || (sns[0] || 'unknown');

        // device status
        if (device.status !== undefined) {
          const m = 'foxess_device_status';
          lines.push(`# TYPE ${m} gauge`);
          lines.push(`${m}{deviceSN="${deviceSN}"} ${Number(device.status)}`);
        }

        // candidate lists where metrics may live
        const candidates = [device.datas, device.data, device.result, device.datasList];
        let found = false;
        for (const cand of candidates) {
          if (Array.isArray(cand)) {
            for (const d of cand) {
              // d may be { variable, value, unit } or [variable, value]
              let variable = null;
              let rawVal = null;
              let unit = '';
              if (d && typeof d === 'object') {
                if (Array.isArray(d)) {
                  variable = d[0];
                  rawVal = d[1];
                } else {
                  variable = d.variable || d.name || d.key || Object.keys(d)[0];
                  rawVal = d.value ?? d.val ?? d[variable] ?? null;
                  unit = d.unit || '';
                }
              } else {
                // primitive value, skip
                continue;
              }

              if (!variable) variable = 'unknown';
              const val = Number(rawVal);
              if (!isNaN(val)) {
                const metric = sanitizeMetricName(String(variable));
                lines.push(`# TYPE ${metric} gauge`);
                const safeUnit = String(unit).replace(/"/g, '');
                if (safeUnit) {
                  lines.push(`${metric}{deviceSN="${deviceSN}",unit="${safeUnit}"} ${val}`);
                } else {
                  lines.push(`${metric}{deviceSN="${deviceSN}"} ${val}`);
                }
              }
            }
            found = true;
            break;
          }
        }

        // if no array was found, attempt to interpret device as key/value map
        if (!found && device && typeof device === 'object') {
          for (const [k, v] of Object.entries(device)) {
            if (k === 'deviceSN' || k === 'status' || k === 'sns') continue;
            const val = Number(v);
            if (!isNaN(val)) {
              const metric = sanitizeMetricName(k);
              lines.push(`# TYPE ${metric} gauge`);
              lines.push(`${metric}{deviceSN="${deviceSN}"} ${val}`);
            }
          }
        }
      }
    }

    // Fallback parsing: if result contains objects with 'datas' arrays under result[x].datas or result[x].datas
    if (data && data.errno === 0 && Array.isArray(data.result)) {
      for (const r of data.result) {
        const deviceSN = r.deviceSN || r.emsSN || (r.sns && r.sns[0]) || (sns[0] || 'unknown');
        const list = r.datas || r.result || r.data || [];
        if (Array.isArray(list)) {
          for (const d of list) {
            const variable = d.variable || d.name || d[0] || 'unknown';
            const rawVal = d.value || d[1] || d.data || d;
            const val = Number(rawVal);
            if (!isNaN(val)) {
              const metric = sanitizeMetricName(variable);
              lines.push(`# TYPE ${metric} gauge`);
              lines.push(`${metric}{deviceSN="${deviceSN}"} ${val}`);
            }
          }
        }
      }
    }

    lastMetrics = lines.join('\n') + '\n';
    lastFetch = Date.now();
    console.log('Metrics updated', new Date().toISOString());
  } catch (err) {
    console.error('Failed to fetch metrics:', err.response?.data || err.message);
  }
}

// Initial fetch
fetchAndBuildMetrics();
setInterval(fetchAndBuildMetrics, POLL_INTERVAL_MS);

import http from 'http';

const server = http.createServer((req, res) => {
  if (req.url === '/metrics') {
    res.writeHead(200, { 'Content-Type': 'text/plain; version=0.0.4' });
    res.end(lastMetrics);
    return;
  }
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('FoxESS exporter. Metrics available at /metrics\n');
});

server.listen(PORT, () => console.log(`FoxESS exporter listening on ${PORT}, poll interval ${POLL_INTERVAL_MS}ms`));
